# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test using AI Type  and AI Model 

ROOST_METHOD_HASH=factorial_f8b08b8cd2
ROOST_METHOD_SIG_HASH=factorial_3a2a5892fb


Scenario 1: Validating factorial of zero
Details:
  TestName: test_factorial_of_zero
  Description: Verify that the function correctly returns 1 when the input is 0, as 0! is defined to be 1.
Execution:
  Arrange: Initialize the input number to 0.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the return value is 1.
Validation:
  This scenario is important because the factorial of 0 is a special case and must return 1 according to mathematical definition.

Scenario 2: Validating factorial of one
Details:
  TestName: test_factorial_of_one
  Description: Verify that the function correctly returns 1 when the input is 1, as 1! is defined to be 1.
Execution:
  Arrange: Initialize the input number to 1.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the return value is 1.
Validation:
  This scenario ensures that the function handles the smallest positive integer correctly.

Scenario 3: Validating factorial of a positive integer
Details:
  TestName: test_factorial_of_positive_integer
  Description: Verify that the function correctly calculates the factorial of a given positive integer.
Execution:
  Arrange: Initialize the input number to a known positive integer, such as 5.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the return value is 120, as 5! = 120.
Validation:
  This scenario tests the core functionality of the factorial calculation for general positive integers.

Scenario 4: Validating factorial of a larger positive integer
Details:
  TestName: test_factorial_of_larger_positive_integer
  Description: Verify that the function correctly calculates the factorial of a larger positive integer.
Execution:
  Arrange: Initialize the input number to a larger positive integer, such as 10.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the return value is 3628800, as 10! = 3628800.
Validation:
  This scenario ensures that the function can handle larger inputs and still produce correct results.

Scenario 5: Validating factorial with negative input
Details:
  TestName: test_factorial_of_negative_integer
  Description: Verify that the function handles negative integer inputs appropriately, even though factorials are not defined for negative numbers.
Execution:
  Arrange: Initialize the input number to a negative integer, such as -5.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the function raises an appropriate exception or error.
Validation:
  This scenario tests the function's robustness and error handling for invalid inputs.

Scenario 6: Validating factorial of a large integer to check performance
Details:
  TestName: test_factorial_performance_large_integer
  Description: Verify that the function can handle very large integers efficiently without excessive delay or resource consumption.
Execution:
  Arrange: Initialize the input number to a very large integer, such as 100.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the function returns the correct result within a reasonable time frame.
Validation:
  This scenario ensures that the function is performant and scalable for large inputs, which is important for practical use cases.

Scenario 7: Validating factorial for typical edge case just above zero
Details:
  TestName: test_factorial_edge_case_just_above_zero
  Description: Verify that the function correctly calculates the factorial for the smallest positive integer, just above zero.
Execution:
  Arrange: Initialize the input number to 2.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the return value is 2, as 2! = 2.
Validation:
  This scenario ensures that the function handles small positive integers correctly, particularly those just above zero.

Scenario 8: Validating factorial for typical edge case just below a larger number
Details:
  TestName: test_factorial_edge_case_just_below_large_number
  Description: Verify that the function correctly calculates the factorial for a number just below a larger integer threshold.
Execution:
  Arrange: Initialize the input number to 9.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the return value is 362880, as 9! = 362880.
Validation:
  This scenario ensures that the function handles intermediate-sized integers correctly, particularly those just below a larger threshold.

Scenario 9: Validating factorial with non-integer input
Details:
  TestName: test_factorial_with_non_integer_input
  Description: Verify that the function handles non-integer inputs appropriately, even though factorials are not defined for non-integers.
Execution:
  Arrange: Initialize the input number to a non-integer, such as 4.5.
  Act: Call the `factorial` function with the input number.
  Assert: Check that the function raises an appropriate exception or error.
Validation:
  This scenario tests the function's robustness and error handling for invalid inputs, ensuring it handles non-integers gracefully.
"""

# ********RoostGPT********
# factorial.py (place this in the Calculator directory)
def factorial(num):
    if not isinstance(num, int):
        raise TypeError("Input must be an integer")
    if num < 0:
        raise ValueError("Input must be a non-negative integer")
    if num == 0:
        return 1
    result = 1
    for i in range(1, num + 1):
        result *= i
    return result
