# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test using AI Type  and AI Model 

ROOST_METHOD_HASH=complex_arithmetic_f741b6bf8c
ROOST_METHOD_SIG_HASH=complex_arithmetic_f8b10a9dcc


### Scenario 1: Complex Addition with Positive Integers
Details:
  TestName: test_complex_addition_positive_integers
  Description: Verify that the function correctly performs complex addition when provided with positive integer inputs.
Execution:
  Arrange: Prepare input choice '1' and a string of positive integers separated by space.
  Act: Invoke the function and simulate user input.
  Assert: Check if the returned result matches the expected complex number format.
Validation:
  This test ensures that the function correctly sums the real and imaginary parts of positive integers, validating the basic functionality of complex addition.

### Scenario 2: Complex Addition with Negative Integers
Details:
  TestName: test_complex_addition_negative_integers
  Description: Verify that the function correctly performs complex addition when provided with negative integer inputs.
Execution:
  Arrange: Prepare input choice '1' and a string of negative integers separated by space.
  Act: Invoke the function and simulate user input.
  Assert: Check if the returned result matches the expected complex number format.
Validation:
  This test ensures that the function correctly handles negative integers, validating the robustness of complex addition.

### Scenario 3: Complex Subtraction with Mixed Integers
Details:
  TestName: test_complex_subtraction_mixed_integers
  Description: Verify that the function correctly performs complex subtraction when provided with a mix of positive and negative integers.
Execution:
  Arrange: Prepare input choice '2' and a string of mixed integers separated by space.
  Act: Invoke the function and simulate user input.
  Assert: Check if the returned result matches the expected complex number format.
Validation:
  This test ensures that the function correctly subtracts real and imaginary parts, validating the functionality of complex subtraction with mixed inputs.

### Scenario 4: Complex Multiplication with Zero
Details:
  TestName: test_complex_multiplication_with_zero
  Description: Verify that the function correctly handles complex multiplication when one or more of the inputs are zero.
Execution:
  Arrange: Prepare input choice '3' and a string of integers where one or more values are zero.
  Act: Invoke the function and simulate user input.
  Assert: Check if the returned result matches the expected complex number format.
Validation:
  This test ensures that the function correctly handles multiplication involving zero, validating the edge case handling in complex multiplication.

### Scenario 5: Complex Division with Non-Zero Integers
Details:
  TestName: test_complex_division_non_zero_integers
  Description: Verify that the function correctly performs complex division with non-zero integer inputs.
Execution:
  Arrange: Prepare input choice '4' and a string of non-zero integers separated by space.
  Act: Invoke the function and simulate user input.
  Assert: Check if the returned result matches the expected complex number format.
Validation:
  This test ensures that the function correctly handles division operations, validating the accuracy of complex division.

### Scenario 6: Complex Division by Zero
Details:
  TestName: test_complex_division_by_zero
  Description: Verify that the function correctly handles division by zero and returns an appropriate error or message.
Execution:
  Arrange: Prepare input choice '4' and a string of integers where the divisor is zero.
  Act: Invoke the function and simulate user input.
  Assert: Check if the function raises an appropriate error or handles the edge case gracefully.
Validation:
  This test ensures that the function correctly handles division by zero, which is a critical edge case in arithmetic operations.

### Scenario 7: Complex Addition with Insufficient Inputs
Details:
  TestName: test_complex_addition_insufficient_inputs
  Description: Verify that the function handles cases where fewer than the required number of inputs are provided for complex addition.
Execution:
  Arrange: Prepare input choice '1' and a string with less than the required number of integers.
  Act: Invoke the function and simulate user input.
  Assert: Check if the function raises an appropriate error or handles the input gracefully.
Validation:
  This test ensures that the function can handle scenarios where the input is insufficient for the operation, validating input validation logic.

### Scenario 8: Complex Subtraction with Insufficient Inputs
Details:
  TestName: test_complex_subtraction_insufficient_inputs
  Description: Verify that the function handles cases where fewer than the required number of inputs are provided for complex subtraction.
Execution:
  Arrange: Prepare input choice '2' and a string with less than the required number of integers.
  Act: Invoke the function and simulate user input.
  Assert: Check if the function raises an appropriate error or handles the input gracefully.
Validation:
  This test ensures that the function can handle scenarios where the input is insufficient for the operation, validating input validation logic.

### Scenario 9: Invalid Choice Input
Details:
  TestName: test_invalid_choice_input
  Description: Verify that the function handles invalid choice inputs gracefully.
Execution:
  Arrange: Prepare an invalid choice input (not '1', '2', '3', or '4').
  Act: Invoke the function and simulate user input.
  Assert: Check if the function raises an appropriate error or handles the invalid choice gracefully.
Validation:
  This test ensures that the function can handle invalid choice inputs, validating user input validation logic.

### Scenario 10: Complex Multiplication with Maximum Elements
Details:
  TestName: test_complex_multiplication_max_elements
  Description: Verify that the function correctly handles complex multiplication with the maximum number of allowed inputs.
Execution:
  Arrange: Prepare input choice '3' and a string of exactly four integer inputs.
  Act: Invoke the function and simulate user input.
  Assert: Check if the returned result matches the expected complex number format.
Validation:
  This test ensures that the function correctly handles the maximum number of inputs, validating the function's capability to manage upper bounds of input size.

### Scenario 11: Complex Division with Maximum Elements
Details:
  TestName: test_complex_division_max_elements
  Description: Verify that the function correctly handles complex division with the maximum number of allowed inputs.
Execution:
  Arrange: Prepare input choice '4' and a string of exactly four integer inputs.
  Act: Invoke the function and simulate user input.
  Assert: Check if the returned result matches the expected complex number format.
Validation:
  This test ensures that the function correctly handles the maximum number of inputs, validating the function's capability to manage upper bounds of input size.
"""

# ********RoostGPT********
def complex_arithmetic():
    print("Enter '1' for complex addition")
    print("Enter '2' for complex subtraction")
    print("Enter '3' for complex multiplication")
    print("Enter '4' for complex division")
    choice = input("Enter your choice: ")

    if choice not in {'1', '2', '3', '4'}:
        print("Invalid choice")
        return None

    nums = list(map(int, input("Enter all numbers separated by space: ").split()))

    if len(nums) != 4:
        raise IndexError("Exactly 4 integers are required")

    real1, imag1, real2, imag2 = nums

    if choice == '1':  # Addition
        real_sum = real1 + real2
        imag_sum = imag1 + imag2
        return f"{real_sum}+ i{imag_sum}"

    elif choice == '2':  # Subtraction
        real_sub = real1 - real2
        imag_sub = imag1 - imag2
        return f"{real_sub}+ i{imag_sub}"

    elif choice == '3':  # Multiplication
        real = real1 * real2 - imag1 * imag2
        imag = real1 * imag2 + real2 * imag1
        return f"{real}+ i{imag}"

    elif choice == '4':  # Division
        if real2 == 0 and imag2 == 0:
            raise ZeroDivisionError("Cannot divide by zero")
        denominator = real2 ** 2 + imag2 ** 2
        real = (real1 * real2 + imag1 * imag2) / denominator
        imag = (imag1 * real2 - real1 * imag2) / denominator
        return f"{real}+ i{imag}"
